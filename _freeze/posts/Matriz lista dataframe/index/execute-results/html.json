{
  "hash": "98df7c161ae313628f9597fa7511a8b6",
  "result": {
    "markdown": "---\ntitle: \"4. Vectores, Matrices, listas y dataframes\"\ndescription: \"Objetos m치s complejos, distinguirlos y extraer informaci칩n\"\nauthor: \"Gabriel Andrade Ponce\"\ndate: \"2022-11-24\"\n---\n\n\n# Vectores\n\nLos vectores son objetos que llevan una colecci칩n de uno o m치s datos del mismo tipo. El tipo del vector es igual al tipo de datos que contiene y solo puede contener datos del mismo tipo. Los vectores tambi칠n tienen un largo, es decir el n칰mero de datos que contiene.\n\n![](vectors.png){fig-align=\"center\"}\n\nEn esencia un solo n칰mero o car치cter es un vector de largo 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nminivec <- 25\nis.vector(minivec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nlength(minivec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n## Concatenar\n\nPara generar vectores de mayor tama침o debemos usar la funci칩n de `c()`o concatenar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vector numerico\nvec1 <- c(1,223,4,5)\nlength(vec1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nclass(vec1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\n# Vector de caracteres\nvec2 <- c(\"a\", \"b\", \"c\", \"d\")\nclass(vec2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\n# Vector l칩gico\n\nvec3 <- c(TRUE, FALSE, TRUE, FALSE)\nclass(vec2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\n# Si admite NA\n\nvec4 <- c(2.5, 30, 45.5, NA)\nclass(vec4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nPodemos incluso concatenar objetos que contengan vectores de la misma clase\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec5 <- c(27,28,29,30)\n(vec6 <- c(vec1, vec5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   1 223   4   5  27  28  29  30\n```\n:::\n:::\n\n\n쯈ue sucede cuando creamos un vector con dos tipos de datos?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec7 <- c(1,2,3, \"4\")\nclass(vec7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n![](/posts/Ayuda%20R/teletubo.png){fig-align=\"center\" width=\"290\"}\n\n## Secuencias\n\nPodemos crear vectores mediante funci칩n de secuencia. Cuando es una secuencia sencilla podemos usar el comando `:`. Si necesitamos secuencias m치s espec칤ficas o con ciertas caracter칤sticas, entonces podemos usar la funci칩n `seq`. 칄sta funci칩n tiene varios argumentos, `from` es el n칰mero de inicio, el `to` el n칰mero final, `length.out` sirve para controlar el largo del vector y mediante `by` podemos especificar el intervalo de la secuencia.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(vec_seq1 <- 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\n(vec_seq2 <- seq(from=1, # Valor de inicio\n               to= 6,\n               length.out= 10)) # Valor final\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.000000 1.555556 2.111111 2.666667 3.222222 3.777778 4.333333 4.888889\n [9] 5.444444 6.000000\n```\n:::\n\n```{.r .cell-code}\n(vec_seq3 <- seq(from= 1,\n                to= 10,\n                by= 0.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0\n[16]  8.5  9.0  9.5 10.0\n```\n:::\n:::\n\n\n## Repetir valores\n\n`rep` permite repetir valores un determinado n칰mero de veces. El argumento de `times` nos permite especificar el n칰mero de veces que un valor o un vector se va a repetir. Cuando especificamos `each` podemos controlar el n칰mero de veces que se repite cada valor dentro del vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(vec_rep1 <- rep(x=25,\n                times= 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25 25 25 25 25\n```\n:::\n\n```{.r .cell-code}\n(vec_rep2 <- rep(vec_rep1,\n                 times=3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25\n```\n:::\n\n```{.r .cell-code}\n(vec_rep3 <- rep(vec2,\n                each=3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"c\" \"c\" \"c\" \"d\" \"d\" \"d\"\n```\n:::\n:::\n\n\n## Caso de factores\n\nLos factores son un caso especial de los caracteres y tienen la peculiaridad de que est치n compuestos por niveles. En otras palabras los factores pueden asumir un n칰mero limitado de valores posibles conocidos o niveles.\n\nPor ejemplo, imaginemos un experimento donde se aplica el tratamiento de sombra a unas plantas en crecimiento. En este caso el tratamiento de sombra es un factor y puede tomar \"si\" cuando tiene sombra o \"no\" cuando no se aplic칩 sombra. Para crear un factor usamos la funci칩n `factor`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsomb <- c(rep(\"si\", 5), rep(\"no\", 5))\n\nfact_somb <- factor(somb)\n\nclass(somb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(fact_somb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n:::\n\n\nEs importante especificar los factores porque muchos funciones y an치lisis estad칤sticos requieren de usar objetos de tipo factor.\n\n## Crear vectores basados en n칰meros aleatorios\n\nPodemos crear vectores basados en n칰meros al azar basados en una distribuci칩n. Por ejemplo, la m치s com칰n es la distribuci칩n normal y se crea mediante `rnorm`. 칄sta funci칩n hace parte de una familia de funciones basadas en distribuciones (ver help de rnorm) y b치sicamente genera n칰meros aleatorios basados en una distribuci칩n normal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# en este ejemplo vamos a crear un vector de 100 valores\nvec_norm <- rnorm(100, \n                  mean = 0, \n                  sd=1)\nis.vector(vec_norm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Selecci칩n de elementos\n\nEn los vectores podemos seleccionar valores con `[]` , el n칰mero que pongamos dentro ser치 la posici칩n del valor que seleccionaremos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_rep3[1] # el primer valor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n\n```{.r .cell-code}\nvec_rep2[5] # el quinto valor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n\nPodemos seleccionar varios valores utilizando el comando de concatenar\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_seq3[c(1,5,9)] # Seleccionamos el primer, el quinto y el 9 valor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5\n```\n:::\n:::\n\n\n## Operaciones de vectores\n\nLas operaciones aritm칠ticas y l칩gicas tambi칠n funcionan con vectores. Pero en este caso obtenemos un resultado por cada elemento\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(vec_sum <- vec_seq3 + 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0 10.5 11.0 11.5 12.0 12.5 13.0\n[16] 13.5 14.0 14.5 15.0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_seq3 > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n\n# Matrices\n\nLas matrices son vectores multi-dimensionales y al igual que los vectores solo pueden contener un tipo de datos. Las matrices tienen dos dimensiones \"alto\" dado por el n칰mero de filas y \"largo\" por el n칰mero de columnas.\n\n![](Matrix.png)\n\nPodemos crear una matriz a partir de un vector, especificando las dimensiones de columnas por medio de la funci칩n `matrix`. Los argumentos de `nrow` y `ncol` ayudan a definir el n칰mero de filas y columnas respectivamente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x1 <- matrix(1:20))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n [1,]    1\n [2,]    2\n [3,]    3\n [4,]    4\n [5,]    5\n [6,]    6\n [7,]    7\n [8,]    8\n [9,]    9\n[10,]   10\n[11,]   11\n[12,]   12\n[13,]   13\n[14,]   14\n[15,]   15\n[16,]   16\n[17,]   17\n[18,]   18\n[19,]   19\n[20,]   20\n```\n:::\n\n```{.r .cell-code}\n# Podemos especificar las columnas y las filas\n\nmatrix(1:20, nrow = 5, ncol = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n```\n:::\n\n```{.r .cell-code}\nmatrix(1:20, nrow = 10, ncol = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    1   11    1   11    1   11    1   11    1    11\n [2,]    2   12    2   12    2   12    2   12    2    12\n [3,]    3   13    3   13    3   13    3   13    3    13\n [4,]    4   14    4   14    4   14    4   14    4    14\n [5,]    5   15    5   15    5   15    5   15    5    15\n [6,]    6   16    6   16    6   16    6   16    6    16\n [7,]    7   17    7   17    7   17    7   17    7    17\n [8,]    8   18    8   18    8   18    8   18    8    18\n [9,]    9   19    9   19    9   19    9   19    9    19\n[10,]   10   20   10   20   10   20   10   20   10    20\n```\n:::\n\n```{.r .cell-code}\nmatrix(1:20, nrow = 4, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in matrix(1:20, nrow = 4, ncol = 3): la longitud de los datos [20] no es\nun subm칰ltiplo o m칰ltiplo del n칰mero de columnas [3] en la matriz\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n:::\n:::\n\n\nA veces es m치s intuitivo unir dos o m치s vectores previamente existentes, por lo que en estos casos podemos combinarlos por filas `rbind` o por columnas `cbind` .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- 1:4\nv2 <- 9:12\nv3 <- 13:16\n\n(m1 <- rbind(v1, v2, v3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1] [,2] [,3] [,4]\nv1    1    2    3    4\nv2    9   10   11   12\nv3   13   14   15   16\n```\n:::\n\n```{.r .cell-code}\n(m3 <- cbind(v1, v2, v3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     v1 v2 v3\n[1,]  1  9 13\n[2,]  2 10 14\n[3,]  3 11 15\n[4,]  4 12 16\n```\n:::\n\n```{.r .cell-code}\nclass(m1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\nv4 <- 20:28\n\nm2 <- rbind(v1,v4)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rbind(v1, v4): number of columns of result is not a multiple of\nvector length (arg 1)\n```\n:::\n:::\n\n\nSe pueden combinar vectores de distinto tipo, pero el de tipo car치cter siempre transformar치 al num칠rico. Entonces, cuidado con lo que combinan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv5 <- c(\"1\", \"2\", \"3\", \"4\")\n\n(m4 <- cbind(v1, v5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     v1  v5 \n[1,] \"1\" \"1\"\n[2,] \"2\" \"2\"\n[3,] \"3\" \"3\"\n[4,] \"4\" \"4\"\n```\n:::\n\n```{.r .cell-code}\nstr(m4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:4, 1:2] \"1\" \"2\" \"3\" \"4\" \"1\" \"2\" \"3\" \"4\"\n - attr(*, \"dimnames\")=List of 2\n  ..$ : NULL\n  ..$ : chr [1:2] \"v1\" \"v5\"\n```\n:::\n\n```{.r .cell-code}\ndim(m4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 2\n```\n:::\n\n```{.r .cell-code}\nclass(m4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n\n## Operadores de matrices\n\nSe pueden usar operadores aritm칠ticos en matrices de tipo num칠rico.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm2+1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\nv1    2    3    4    5    2    3    4    5    2\nv4   21   22   23   24   25   26   27   28   29\n```\n:::\n\n```{.r .cell-code}\n# m4+1\n```\n:::\n\n\nPodemos hacer uso de la funci칩n `t()` para transponer una matriz\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Podemos transponer una matriz\nm3t <- t(m3)\n```\n:::\n\n\n## Selecci칩n de valores\n\nIgual que en los vectores podemos usar`[]` para seleccionar valores. La gr치n diferencia es que como las matrices son de 2 dimensiones, debemos especificar ambas en los par칠ntesis y separarlos por una coma: \\[filas , columnas\\]. Cuando seleccionamos m치s de una fila o columna podemos usar `c` para concatenar el vector de selecci칩n. Cuando ponemos un signo de \"menos\" (-) dentro de los par칠ntesis de selecci칩n, vamos a eliminar dicha columna o fila.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vamos a seleccionar la fila 1 y 3 de m3\nm3[c(1,3),]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     v1 v2 v3\n[1,]  1  9 13\n[2,]  3 11 15\n```\n:::\n\n```{.r .cell-code}\n#Tabi칠n podemos seleccionar valores de la diagonal por medio de diag\ndiag(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 10 15\n```\n:::\n\n```{.r .cell-code}\ndiag(m3t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 10 15\n```\n:::\n\n```{.r .cell-code}\n# Eliminar la fila 1 y seleccionar la columna 2\nm3[-1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 11 12\n```\n:::\n\n```{.r .cell-code}\n# Eliminar las filas 1 y 4, y seleccionar las columnas 1 y 3\nm3[c(-1,-4), c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     v1 v3\n[1,]  2 14\n[2,]  3 15\n```\n:::\n:::\n\n\nCunado usamos los selectores al lado izquierdo de la definici칩n de objeto, podemos reemplazar los valores, por los que estamos definiendo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Podemos reemplazar valores de las matrices\n\n# Reemplazar la segunda fila por 100, 200 y 300\nm3[2,] <- c(100,200, 300)\nm3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      v1  v2  v3\n[1,]   1   9  13\n[2,] 100 200 300\n[3,]   3  11  15\n[4,]   4  12  16\n```\n:::\n\n```{.r .cell-code}\n# Reemplazar fila 4 y 3 y columna 2 por 1000\nm3[c(4,3),2] <- 1000\nm3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      v1   v2  v3\n[1,]   1    9  13\n[2,] 100  200 300\n[3,]   3 1000  15\n[4,]   4 1000  16\n```\n:::\n\n```{.r .cell-code}\n# Reemplaza 1 y 3 fila y 1 y 3 fila por 500\nm3[c(1,3), c(1,3)] <- 500\nm3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      v1   v2  v3\n[1,] 500    9 500\n[2,] 100  200 300\n[3,] 500 1000 500\n[4,]   4 1000  16\n```\n:::\n\n```{.r .cell-code}\n# Reemplaza la tercea columna por la 1 columna m치s 3\nm3[,3] <- m3[,1]+3 \nm3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      v1   v2  v3\n[1,] 500    9 503\n[2,] 100  200 103\n[3,] 500 1000 503\n[4,]   4 1000   7\n```\n:::\n:::\n\n\n## Array\n\n![](array.png){fig-align=\"center\"}\n\nEl array es un tipo matriz, pero con m치s de dos dimensiones 游땻游뱚. Las array, al igual que las matrices, solo pueden ser formadas por objetos del mismo tipo. Podemos usar la funci칩n `array` y definir filas, columnas y tercera dimensi칩n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAR1 <- array(1:30, dim = c(3,4,2))\nAR1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n```\n:::\n\n```{.r .cell-code}\nclass(AR1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"array\"\n```\n:::\n\n```{.r .cell-code}\ndim(AR1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 2\n```\n:::\n\n```{.r .cell-code}\nstr(AR1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:3, 1:4, 1:2] 1 2 3 4 5 6 7 8 9 10 ...\n```\n:::\n\n```{.r .cell-code}\n# Seleccionar la celda con el valor de 13\nx <- AR1[,,2]\n```\n:::\n\n\n# Data Frame\n\n![](dataframe.png){fig-align=\"center\"}\n\nLos data frames al igual que las matrices son objetos de dos dimensiones, pero pueden tener diferentes tipos de datos. 칄sta caracter칤stica los convierte en uno de los objetos m치s usados para muchos tipos de an치lisis, por su versatilidad. En general se puede entender las filas de un dataframe como observaciones, casos o individuos y las columnas como variables.\n\nEn los data frames cada columna puede ser de distinto tipo pero todas tienen que ser del mismo largo\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol1 <- 1:5\ncol2 <- c(\"Z\", \"W\", \"L\", \"M\", \"R\")\ncol3 <- c(TRUE, FALSE, FALSE, TRUE, FALSE)\n\ndf1 <- data.frame(numeros= col1,\n                  letras= col2,\n                  logico= col3)\n```\n:::\n\n\nPodemos usar la funci칩n `view` para visualizar el dataframe\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(df1)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div id=\"htmlwidget-d141bc06bef99dc36719\" style=\"width:100%;height:auto;\" class=\"datatables html-widget\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-d141bc06bef99dc36719\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\"],[1,2,3,4,5],[\"Z\",\"W\",\"L\",\"M\",\"R\"],[true,false,false,true,false]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>numeros<\\/th>\\n      <th>letras<\\/th>\\n      <th>logico<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":1},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\nPodemos extraer diferentes caracter칤sticas de los data frames\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# las dimensiones\ndim(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 3\n```\n:::\n\n```{.r .cell-code}\n# Los nombres de las columnas\nnames(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeros\" \"letras\"  \"logico\" \n```\n:::\n\n```{.r .cell-code}\n# La clase\nclass(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n\nPodemos transformar una matriz a un data frame o un data frame con solo n칰meros a una matriz.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- as.data.frame(m3)\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   v1   v2  v3\n1 500    9 503\n2 100  200 103\n3 500 1000 503\n4   4 1000   7\n```\n:::\n:::\n\n\n## Seleccionar en data frame\n\nEn los data frames tambi칠n podemos seleccionar valores por medio de `[]` , incluyendo los nombres de las columnas\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar primera columna\ndf1[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# Seleccionar primera fila\ndf1[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  numeros letras logico\n1       1      Z   TRUE\n```\n:::\n\n```{.r .cell-code}\n# Seleccionar por nombres\ndf1[c(\"letras\", \"logico\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  letras logico\n1      Z   TRUE\n2      W  FALSE\n3      L  FALSE\n4      M   TRUE\n5      R  FALSE\n```\n:::\n:::\n\n\nOtra manera muy com칰n de seleccionar columnas en un data frame es por medio de `$` . El operador de peso selecciona el objeto conservando su clase original, es decir el data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(letras2 <- df1$letras)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Z\" \"W\" \"L\" \"M\" \"R\"\n```\n:::\n:::\n\n\n# Lista\n\n![](Litst.png){fig-align=\"center\"}\n\nLas listas como los vectores son de una sola dimensi칩n. Sin embargo, pueden tener diferentes tipos de valores e incluso de elementos. Una lista puede tener dentro un vector, una matriz, un data frame e incluso otra lista\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- 1:10\ndf <- data.frame(num= 1:4, letra= letters[1:4])\n\nlista <- list(vector=v, dataframe= df, Matriz= m3)\n\ndim(lista)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nlength(lista)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nPodemos utilizar los selectores que ya vimos en las listas\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# selecci칩n que resulta en lista\n(v2 <- lista[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vector\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\n# Selecci칩n que termina en vector\n(v3 <- lista[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nclass(v3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\n# Selecci칩n de dataframe\n(df_list <- lista[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  num letra\n1   1     a\n2   2     b\n3   3     c\n4   4     d\n```\n:::\n\n```{.r .cell-code}\n# Selecci칩n termina en matriz\n(mat <- lista$Matriz)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      v1   v2  v3\n[1,] 500    9 503\n[2,] 100  200 103\n[3,] 500 1000 503\n[4,]   4 1000   7\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.5.4/htmlwidgets.js\"></script>\r\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/datatables-binding-0.20/datatables.js\"></script>\r\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\r\n<link href=\"../../site_libs/dt-core-1.11.3/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\r\n<link href=\"../../site_libs/dt-core-1.11.3/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/dt-core-1.11.3/js/jquery.dataTables.min.js\"></script>\r\n<link href=\"../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}